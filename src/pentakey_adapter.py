import json

from config import DefaultConfig

def get_scores(obj):
    # Getting only the scores for reordering purposes
    return [x for x in obj if x['name'] == 'SCORE']

def score_sort_key(ll_score):
    # Returns the y coordinate for the score
    return ll_score['relative_coordinates']['center_y']

def object_sort_key(obj):
    return obj['relative_coordinates']['center_x']

# List of list of scores.
# One list of scores for every frame in the result.json.
def get_arranged_output(output_file):
    # Opens the file in read only mode.
    data = []
    with open(output_file, 'r') as file:
    # Reads the content as JSON object
        data = json.load(file)

    # This will maintain the list of list of scores necessary to sort the readings by row, for the current frame.
    # This will maintain the list of rows
    arranged_output = []
    for entry in data:
        arranged_entry_output = []
        # Passing found classes to the get scores function and ordering them based on the Y coordinate.
        entry_scores = get_scores(entry['objects'])
        entry_scores.sort(key=score_sort_key)
        # Scores are sorted so we'll explore them top to bottom.
        for score in entry_scores:
            # Add for every score object the notes that fall within its boundaries
            # print(score['relative_coordinates']['center_y'])
            # print(score['relative_coordinates']['height'])
            # For every score we create a list that contains all of the objects for said score.
            score_scope = []
            for obj in entry['objects']:
                if score['relative_coordinates']['center_y'] - (score['relative_coordinates']['height']/2) <= obj['relative_coordinates']['center_y'] <= score['relative_coordinates']['center_y'] + (score['relative_coordinates']['height']/2):
                    score_scope.append(obj)

            # Refine this step so that we know which comes first and which comes second when there's a half notehead.
            score_scope.sort(key=object_sort_key)
            # Adding current row to the arranged entry output
            arranged_entry_output.append(score_scope)
        arranged_output.append(arranged_entry_output)
    return arranged_output


def write_output(arranged_output, file_name):
    with open(file_name, 'a+') as out:
        json.dump(arranged_output, out)



arranged_output = get_arranged_output(DefaultConfig.INPUT_FOLDER + "/" + DefaultConfig.INPUT_FILE)
write_output(arranged_output, DefaultConfig.OUTPUT_FOLDER + "/" + DefaultConfig.OUTPUT_NORMALIZED_FILE)

# After executing the function, you will have a list of lists (of lists, since there could be more frames). Every list inside the ll will be a row of the score.
# Just as an example here's the first line.

print([x['name'] for x in arranged_output[0][0]])

# Here, arranged output is [0][0] because the input melody has only one frame, so there's always the first [0].


# TODO:
    # Create a class that encapsulate the logic from this script.
    # My idea is to have a generic "adapter" class that takes as an input a file generated by a model and returns a normalized file.
    # This specific file would be an implementation for the adapter of the "pentakey" model, but in the future people can write their own version that performs the rearranging.

# TODO:
    # Logic to parse the arranged output.
    # Rules to bear in mind:
        # If there's no modifier before or after a note, it is assumed it's duration is 1/4.
        # If there's a noteHeadHalf before (it's always before) then the duration is 1/2.
        # Move the "beam" element in the scoreParser to modifiers.
        # To verify the duration, assume that everything between a barline and the other must add to the specified time signature.
        # To specify the key alteration (armor), see where in the SCORE element the keySharp/keyNatural/KeyFlat/doubleSharp is.
        # Bear in mind that the model is dumb: it recognizes only up to 2 sharp. There could be even 4 or 5 in most extreme cases.
        # To add up beams, take a peek 4/5 space before and after the current note. See if you can find a run of beams before or after. See if they intersect. Count how many intersect with the note. Divide the duration by 2 for every beam.
        # Add a mapping that will simply be done AFTER computing the whole spartito to map notes if the key has changed. For example, with gClef we have SI_1. With FClef we have RE_1.
